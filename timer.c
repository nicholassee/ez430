#include <msp430.h>
#include "timer.h"
#include "display.h"
#include "commonVar.h"
#include "temperature.h"
#include "acceleration.h"
#include "commonVar.h"

// *************************************************************************************************
// Global Variable section
struct timer sTimer;
extern void to_lpm(void);
volatile int sec;
volatile int min;
volatile int hr;

// *************************************************************************************************
// @fn          Timer0_Init
// @brief       Set Timer0 to a period of 1 or 2 sec. IRQ TACCR0 is asserted when timer overflows.
// @param       none
// @return      none
// *************************************************************************************************
void Timer0_Init(void) {
	// Set interrupt frequency to 1Hz
	TA0CCR0 = 32768;
	//half a sec for temp
	TA0CCR1 = 32768 / 2;
	TA0CCR2 = 32;
	TA0CCTL2 |= CCIE;
	TA0CCTL1 |= CCIE;
	// Enable timer interrupt
	TA0CCTL0 |= CCIE;

	TA0CTL |= TASSEL_1 + MC_1 + TACLR;
}

// *************************************************************************************************
// @fn          Timer1_Init
// @brief       Set Timer1 to a period of 0.25. IRQ TACCR0 is asserted when timer overflows.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_Init(void)
{
    // Set interrupt frequency to 32Hz (0.25s)
    TA1CCR0 = 32768/4;

    // Enable timer interrupt
    TA1CCTL0 |= CCIE;

    // Clear and start timer now
    // Continuous mode: Count to 0xFFFF and restart from 0 again - 1sec timing will be generated by
    // ISR
    TA1CTL |= TASSEL_1 + MC_1 + TACLR;
}

// *************************************************************************************************
// @fn          Timer0_Start
// @brief       Start Timer0.
// @param       none
// @return      none
// *************************************************************************************************
void Timer0_Start(void) {
	// Start Timer0 in continuous mode
	TA0CTL |= MC_2;
}

// *************************************************************************************************
// @fn          Timer0_Stop
// @brief       Stop and reset Timer0.
// @param       none
// @return      none
// *************************************************************************************************
void Timer0_Stop(void) {
	// Stop Timer0
	TA0CTL &= ~MC_2;

	// Set Timer0 count register to 0x0000
	TA0R = 0;
}

#pragma vector = TIMER1_A0_VECTOR
__interrupt void TIMER1_A0_ISR(void){
	if (watch_mode == 1 && running_status == 0) {
		display_acceleration();
	}else if (running_status == 1 && watch_mode == 1) {
		do_acceleration_measurement();
		display_acceleration();
	}
	__no_operation();
}

#pragma vector = TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void) {
	// Reset value of CCR1
	TA0CCR1 = 32768 / 2;
	TA0CCR2 = 32;
	__no_operation();
	// Add 1 second to global time
	//clock_tick();

	unsigned char * sec_print;
	unsigned char * min_print;
	unsigned char * hr_print;
	
	if (watch_mode == 1 && running_status == 0) {
		sec_print = int_to_array(sec, 2, 0);
		display_chars(LCD_SEG_L2_1_0, sec_print, SEG_ON);
		min_print = int_to_array(min, 2, 0);
		display_chars(LCD_SEG_L2_3_2, min_print, SEG_ON);
		hr_print = int_to_array(hr, 2, 0);
		display_chars(LCD_SEG_L2_5_4, hr_print, SEG_ON);
		//:
		write_lcd_mem((unsigned char *) (0x0a24), (BIT0), (BIT0), SEG_ON);
		//:
		write_lcd_mem((unsigned char *) (0x0a20), (BIT4), (BIT4), SEG_ON);
		//clock icon
		write_lcd_mem((unsigned char *) (0x0a22), (BIT3), (BIT3),
				SEG_ON_BLINK_OFF);

	}else if (running_status == 1 && watch_mode == 1) {
		// to increment internal function seconds timer
		sec += 1;
		if (sec >= 60) {
			sec = 0;
			min += 1;
			if (min >= 60) {
				min = 0;
				hr += 1;
			}
		}

		sec_print = int_to_array(sec, 2, 0);
		display_chars(LCD_SEG_L2_1_0, sec_print, SEG_ON);
		min_print = int_to_array(min, 2, 0);
		display_chars(LCD_SEG_L2_3_2, min_print, SEG_ON);
		hr_print = int_to_array(hr, 2, 0);
		display_chars(LCD_SEG_L2_5_4, hr_print, SEG_ON);
		write_lcd_mem((unsigned char *) (0x0a24), (BIT0), (BIT0), SEG_ON);
		write_lcd_mem((unsigned char *) (0x0a20), (BIT4), (BIT4), SEG_ON);
		write_lcd_mem((unsigned char *) (0x0a22), (BIT3), (BIT3),
				SEG_ON_BLINK_ON);
		//display_symbol(LCD_ICON_BEEPER1, SEG_ON_BLINK_ON);

	}


}

void Timer0_A4_Delay(unsigned short ticks) {
	unsigned short value = 0;

	// Exit immediately if Timer0 not running - otherwise we'll get stuck here
	if ((TA0CTL & (BIT4 | BIT5)) == 0)
		return;

	// Disable timer interrupt
	TA0CCTL4 &= ~CCIE;

	// Clear delay_over flag

	// Add delay to current timer value
	// To make sure this value is correctly read
	while (value != TA0R)
		value = TA0R;
	value += ticks;

	// Update CCR
	TA0CCR4 = value;

	// Reset IRQ flag
	TA0CCTL4 &= ~CCIFG;

	// Enable timer interrupt
	TA0CCTL4 |= CCIE;

	__enable_interrupt();
}

#pragma vector = TIMER0_A1_VECTOR
__interrupt void TIMER0_A1_5_ISR(void) {

	switch (TA0IV) {
		case 0x02:
		{
			if (watch_mode == 0) {
				// add CCR1 value to continue having next interrupt in this CCR0 cycle
				TA0CCR1 += 32768 / 2;
				temperature_measurement();
				display_temperature();
				if (warmup_status == 0) {
					display_chars(LCD_SEG_L2_4_0, (unsigned char*) "READY", SEG_ON);
				} else if (warmup_status == 1) {
					display_chars(LCD_SEG_L2_4_0, (unsigned char*) "ACTIV", SEG_ON);
				} else if (warmup_status == 2) {
					display_chars(LCD_SEG_L2_4_0, (unsigned char*) "DONE", SEG_ON);
				}
	//			puts("watch mode 0");
	//			printf("%d\n", warmup_status);
			}

			break;
		}
		case 0x04:
		{
			if(watch_mode==0 && warmup_status==2){
				TA0CCR2 += 32;
				P2OUT ^= BIT7;
			}else{
				P2OUT &= ~BIT7;
			}
			break;
		}
		// Timer0_A4    One-time delay
	case 0x08:             // Disable IE
		TA0CCTL4 &= ~CCIE;
		// Reset IRQ flag
		TA0CCTL4 &= ~CCIFG;
		// Set delay over flag

		break;
	}

	// Exit from LPM3 on RETI
	_BIC_SR_IRQ(LPM3_bits);
}
__interrupt void TIMER0_A1_ISR(void) {

}
